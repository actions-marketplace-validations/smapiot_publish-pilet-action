"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const VirtualPackager_1 = require("./VirtualPackager");
const bundleUrlRef = '__bundleUrl__';
function isFile(bundleDir, name) {
    const path = path_1.resolve(bundleDir, name);
    return fs_1.existsSync(path) && fs_1.statSync(path).isFile();
}
function resolveModule(name, targetDir) {
    try {
        const moduleDefinitionFile = `${name}/package.json`;
        const moduleDefinition = require(moduleDefinitionFile);
        const replacements = {};
        if (moduleDefinition) {
            const moduleRoot = path_1.dirname(require.resolve(moduleDefinitionFile));
            if (typeof moduleDefinition.browser === 'string') {
                return {
                    name,
                    path: path_1.resolve(moduleRoot, moduleDefinition.browser),
                };
            }
            if (typeof moduleDefinition.browser === 'object') {
                Object.keys(moduleDefinition.browser).forEach(repl => {
                    const desired = moduleDefinition.browser[repl];
                    replacements[path_1.resolve(moduleRoot, repl)] = path_1.resolve(moduleRoot, desired);
                });
            }
            if (typeof moduleDefinition.module === 'string') {
                const modulePath = path_1.resolve(moduleRoot, moduleDefinition.module);
                return {
                    name,
                    path: replacements[modulePath] || modulePath,
                };
            }
        }
        const directPath = require.resolve(name, {
            paths: [targetDir],
        });
        return {
            name,
            path: replacements[directPath] || directPath,
        };
    }
    catch (ex) {
        console.warn(`Could not find module ${name}.`);
        return undefined;
    }
}
function extendBundlerForPilet(bundler) {
    bundler.parser.registerExtension('vm', require.resolve('./VirtualAsset'));
    bundler.packagers.add('vm', VirtualPackager_1.VirtualPackager);
}
exports.extendBundlerForPilet = extendBundlerForPilet;
function modifyBundlerForPilet(proto, externalNames, targetDir) {
    const externals = externalNames.map(name => resolveModule(name, targetDir)).filter(m => !!m);
    const ra = proto.getLoadedAsset;
    proto.getLoadedAsset = function (path) {
        const [external] = externals.filter(m => m.path === path);
        if (external) {
            path = `/${external.name}.vm`;
        }
        return ra.call(this, path);
    };
}
exports.modifyBundlerForPilet = modifyBundlerForPilet;
function postProcess(bundle, prName = '') {
    const bundleUrl = `var ${bundleUrlRef}=function(){try{throw new Error}catch(t){const e=(""+t.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);if(e)return e[0].replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)\\/[^\\/]+$/,"$1")+"/"}return"/"}();`;
    if (!prName) {
        prName = `pr_${bundle.getHash()}`;
    }
    const promise = new Promise((resolve, reject) => {
        if (/js|css/.test(bundle.type)) {
            const bundleDir = path_1.dirname(bundle.name);
            fs_1.readFile(bundle.name, 'utf8', (err, data) => {
                if (err) {
                    return reject(err);
                }
                let result = data.replace(/^module\.exports="(.*)";$/gm, (str, value) => {
                    if (isFile(bundleDir, value)) {
                        return str.replace(`"${value}"`, `${bundleUrlRef}+"${value}"`);
                    }
                    return str;
                });
                if (/js/.test(bundle.type)) {
                    /**
                     * In pure JS bundles (i.e., we are not starting with an HTML file) Parcel
                     * just omits the included CSS... This is bad (to say the least).
                     * Here, we search for any sibling CSS bundles (there should be at most 1)
                     * and include it asap using a standard approach.
                     * Note: In the future we may llow users to disable this behavior (via a Piral
                     * setting to disallow CSS inject).
                     */
                    const [cssBundle] = [...bundle.childBundles].filter(m => /\.css$/.test(m.name));
                    if (cssBundle) {
                        const cssName = path_1.basename(cssBundle.name);
                        const stylesheet = [
                            `var d=document`,
                            `var e=d.createElement("link")`,
                            `e.type="text/css"`,
                            `e.rel="stylesheet"`,
                            `e.href=${bundleUrlRef}+${JSON.stringify(cssName)}`,
                            `d.head.appendChild(e)`,
                        ].join(';');
                        result = `(function(){${stylesheet}})();${result}`;
                    }
                    /*
                     * Wrap the JavaScript output bundle in an IIFE, fixing `global` and
                     * `parcelRequire` declaration problems, and preventing `parcelRequire`
                     * from leaking into global (window).
                     * @see https://github.com/parcel-bundler/parcel/issues/1401
                     */
                    result = [
                        `!(function(global,parcelRequire){'use strict';${bundleUrl}`,
                        result
                            .split('"function"==typeof parcelRequire&&parcelRequire')
                            .join(`"function"==typeof global.${prName}&&global.${prName}`),
                        `;global.${prName}=parcelRequire}(window, window.${prName}));`,
                    ].join('\n');
                }
                fs_1.writeFile(bundle.name, result, 'utf8', err => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        }
        else {
            resolve();
        }
    });
    const promises = [promise];
    bundle.childBundles.forEach(child => promises.push(postProcess(child, prName)));
    return Promise.all(promises).then(() => { });
}
exports.postProcess = postProcess;
//# sourceMappingURL=pilet.js.map