"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const io_1 = require("./io");
const info_1 = require("./info");
const log_1 = require("./log");
const language_1 = require("./language");
function getPiralPath(root, name) {
    return path_1.resolve(root, 'node_modules', name);
}
function getDependencyVersion(name, devDependencies, allDependencies) {
    const version = devDependencies[name];
    const selected = typeof version === 'string' ? version : version === true ? allDependencies[name] : undefined;
    if (!selected) {
        log_1.logWarn(`The version for "${name}" could not be resolved. Using "latest".`);
    }
    return selected || 'latest';
}
function getMatchingFiles(source, target, file, mirror = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const { from, to, deep = false } = typeof file === 'string' ? { from: file, to: file, deep: false } : file;
        const sourcePath = path_1.resolve(source, from);
        const targetPath = path_1.resolve(target, mirror ? from : to);
        const isDirectory = yield io_1.checkIsDirectory(sourcePath);
        if (isDirectory) {
            const pattern = deep ? '**/*' : '*';
            const files = yield io_1.matchFiles(sourcePath, pattern);
            return files.map(file => ({
                sourcePath: file,
                targetPath: path_1.resolve(targetPath, path_1.relative(sourcePath, file)),
            }));
        }
        return [
            {
                sourcePath,
                targetPath,
            },
        ];
    });
}
function getFilesOf(root, name, file) {
    const source = getPiralPath(root, name);
    return getMatchingFiles(source, root, file);
}
function findPackageRoot(pck, baseDir) {
    try {
        return require.resolve(`${pck}/package.json`, {
            paths: [baseDir],
        });
    }
    catch (ex) {
        return undefined;
    }
}
exports.findPackageRoot = findPackageRoot;
function findPackage(pck, baseDir) {
    if (Array.isArray(pck)) {
        for (const item of pck) {
            const result = findPackage(item, baseDir);
            if (result) {
                return result;
            }
        }
    }
    else {
        const path = findPackageRoot(pck, baseDir);
        if (path) {
            const appPackage = require(path);
            const relPath = appPackage && appPackage.app;
            appPackage.app = relPath && path_1.resolve(path_1.dirname(path), relPath);
            return appPackage;
        }
    }
    return undefined;
}
function readPiralPackage(root, name) {
    const path = getPiralPath(root, name);
    return io_1.readJson(path, 'package.json');
}
exports.readPiralPackage = readPiralPackage;
function getPiralPackage(app, language) {
    return {
        app,
        scripts: {
            start: 'piral debug',
            build: 'piral build',
        },
        pilets: Object.assign(Object.assign({}, getPiletsInfo({})), { scripts: {
                build: 'npm run build-pilet',
                start: 'npm run debug-pilet',
            } }),
        devDependencies: Object.assign(Object.assign({}, language_1.getDevDependencies(language)), { 'piral-cli': `${info_1.cliVersion}` }),
    };
}
exports.getPiralPackage = getPiralPackage;
function getFileStats(root, name, files = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = [];
        yield Promise.all(files.map((file) => __awaiter(this, void 0, void 0, function* () {
            const subfiles = yield getFilesOf(root, name, file);
            for (const subfile of subfiles) {
                const { sourcePath, targetPath } = subfile;
                const sourceHash = yield io_1.getHash(sourcePath);
                const targetHash = yield io_1.getHash(targetPath);
                results.push({
                    path: targetPath,
                    hash: targetHash,
                    changed: sourceHash !== targetHash,
                });
            }
        })));
        return results;
    });
}
exports.getFileStats = getFileStats;
function copyFiles(subfiles, forceOverwrite, originalFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const subfile of subfiles) {
            const { sourcePath, targetPath } = subfile;
            const overwrite = originalFiles.some(m => m.path === targetPath && !m.changed);
            const force = overwrite ? io_1.ForceOverwrite.yes : forceOverwrite;
            yield io_1.copy(sourcePath, targetPath, force);
        }
    });
}
function copyScaffoldingFiles(source, target, files) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const file of files) {
            const subfiles = yield getMatchingFiles(source, target, file, true);
            yield copyFiles(subfiles, io_1.ForceOverwrite.yes, []);
        }
    });
}
exports.copyScaffoldingFiles = copyScaffoldingFiles;
function copyPiralFiles(root, name, files, forceOverwrite, originalFiles = []) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const file of files) {
            const subfiles = yield getFilesOf(root, name, file);
            yield copyFiles(subfiles, forceOverwrite, originalFiles);
        }
    });
}
exports.copyPiralFiles = copyPiralFiles;
function getPiletsInfo(piralInfo) {
    const { files = [], externals = [], scripts = {}, validators = {}, devDependencies = {}, preScaffold = '', postScaffold = '', preUpgrade = '', postUpgrade = '', } = piralInfo.pilets || {};
    return {
        files,
        externals,
        scripts,
        validators,
        devDependencies,
        preScaffold,
        postScaffold,
        preUpgrade,
        postUpgrade,
    };
}
exports.getPiletsInfo = getPiletsInfo;
function retrievePiralRoot(baseDir, entry) {
    return __awaiter(this, void 0, void 0, function* () {
        const rootDir = path_1.join(baseDir, entry);
        if (path_1.extname(rootDir) !== '.html') {
            const packageName = path_1.basename(rootDir) === 'package.json' ? rootDir : path_1.join(rootDir, 'package.json');
            const exists = yield io_1.checkExists(packageName);
            if (!exists) {
                log_1.logFail(`Cannot find a valid entry point. Missing package.json in "%s".`, rootDir);
                throw new Error('Invalid Piral instance.');
            }
            const { app } = require(packageName);
            if (!app) {
                log_1.logFail(`Cannot find a valid entry point. Missing field "%s" in the "%s".`, 'app', 'package.json');
                throw new Error('Invalid Piral instance.');
            }
            return path_1.join(path_1.dirname(packageName), app);
        }
        return rootDir;
    });
}
exports.retrievePiralRoot = retrievePiralRoot;
function findPackageVersion(rootPath, packageName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const moduleName = require.resolve(packageName, {
                paths: [rootPath],
            });
            const packageJson = yield io_1.findFile(moduleName, 'package.json');
            return require(packageJson).version;
        }
        catch (e) {
            log_1.logWarn(`Could not resolve "${packageName}" from "${rootPath}". Taking "latest" version.`);
            return 'latest';
        }
    });
}
exports.findPackageVersion = findPackageVersion;
function retrievePiletsInfo(entryFile) {
    return __awaiter(this, void 0, void 0, function* () {
        const exists = yield io_1.checkExists(entryFile);
        if (!exists) {
            log_1.logFail(`The given entry pointing to "%s" does not exist.`, entryFile);
            throw new Error('Invalid Piral instance.');
        }
        const packageJson = yield io_1.findFile(entryFile, 'package.json');
        if (!packageJson) {
            log_1.logFail('Cannot find any package.json. You need a valid package.json for your Piral instance.');
            throw new Error('Invalid Piral instance.');
        }
        const packageInfo = require(packageJson);
        return Object.assign(Object.assign({}, getPiletsInfo(packageInfo)), { name: packageInfo.name, version: packageInfo.version, dependencies: {
                std: packageInfo.dependencies || {},
                dev: packageInfo.devDependencies || {},
                peer: packageInfo.peerDependencies || {},
            }, root: path_1.dirname(packageJson) });
    });
}
exports.retrievePiletsInfo = retrievePiletsInfo;
function patchPiletPackage(root, name, version, piralInfo, language) {
    return __awaiter(this, void 0, void 0, function* () {
        const piralDependencies = piralInfo.devDependencies || {};
        const typeDependencies = language !== undefined ? language_1.getDevDependencies(language) : {};
        const _a = getPiletsInfo(piralInfo), { externals } = _a, info = __rest(_a, ["externals"]);
        const piral = Object.assign({ comment: 'Keep this section to allow running `piral upgrade`.', name, version: piralInfo.version, tooling: info_1.cliVersion, externals }, info);
        const allExternals = [...externals, ...info_1.coreExternals];
        const scripts = Object.assign({ 'debug-pilet': 'pilet debug', 'build-pilet': 'pilet build', 'upgrade-pilet': 'pilet upgrade' }, info.scripts);
        const peerDependencies = Object.assign(Object.assign({}, allExternals.reduce((deps, name) => {
            deps[name] = '*';
            return deps;
        }, {})), { [name]: `*` });
        const devDependencies = Object.assign(Object.assign(Object.assign(Object.assign({}, Object.keys(typeDependencies).reduce((deps, name) => {
            deps[name] = piralDependencies[name] || typeDependencies[name];
            return deps;
        }, {})), Object.keys(info.devDependencies).reduce((deps, name) => {
            deps[name] = getDependencyVersion(name, info.devDependencies, piralDependencies);
            return deps;
        }, {})), allExternals.reduce((deps, name) => {
            deps[name] = piralDependencies[name] || 'latest';
            return deps;
        }, {})), { [name]: `${version || piralInfo.version}`, 'piral-cli': `^${info_1.cliVersion}` });
        yield io_1.updateExistingJson(root, 'package.json', {
            piral,
            devDependencies,
            peerDependencies,
            scripts,
        });
        return info.files;
    });
}
exports.patchPiletPackage = patchPiletPackage;
function retrievePiletData(target, app) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield io_1.findFile(target, 'package.json');
        if (!packageJson) {
            log_1.logFail('Cannot find the "%s". You need a valid package.json for your pilet.', 'package.json');
            throw new Error('Invalid pilet.');
        }
        const root = path_1.dirname(packageJson);
        const packageContent = require(packageJson);
        const appPackage = findPackage(app || (packageContent.piral && packageContent.piral.name) || Object.keys(packageContent.devDependencies), target);
        const appFile = appPackage && appPackage.app;
        if (!appFile) {
            log_1.logFail('Cannot find the Piral instance. Make sure the "%s" of the Piral instance is valid (has an "%s" field).', 'package.json', 'app');
            throw new Error('Invalid Piral instance selected.');
        }
        const { piralCLI = { generated: false } } = appPackage;
        if (!piralCLI.generated) {
            log_1.logWarn(`The used Piral instance does not seem to be a proper development package.
Please make sure to build your development package with the Piral CLI using "piral build".`);
        }
        return {
            dependencies: packageContent.dependencies || {},
            devDependencies: packageContent.devDependencies || {},
            peerDependencies: packageContent.peerDependencies || {},
            appFile,
            appPackage,
            root,
        };
    });
}
exports.retrievePiletData = retrievePiletData;
//# sourceMappingURL=package.js.map