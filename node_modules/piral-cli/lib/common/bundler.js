"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@babel/core");
const path_1 = require("path");
const io_1 = require("./io");
const log_1 = require("./log");
const bundleWithCodegen = require('parcel-plugin-codegen');
function openBrowser(shouldOpen, port) {
    return __awaiter(this, void 0, void 0, function* () {
        if (shouldOpen) {
            try {
                const open = require('opn');
                yield open(`http://localhost:${port}`, undefined);
            }
            catch (err) {
                log_1.logFail(`Unexpected error while opening in browser: ${err}`);
            }
        }
    });
}
exports.openBrowser = openBrowser;
function extendBundlerWithPlugins(bundler) {
    bundleWithCodegen(bundler);
}
exports.extendBundlerWithPlugins = extendBundlerWithPlugins;
function clearCache(root, dir = '.cache') {
    return __awaiter(this, void 0, void 0, function* () {
        const cacheDir = path_1.resolve(root, dir);
        const exists = yield io_1.checkExists(cacheDir);
        if (exists) {
            yield io_1.removeDirectory(cacheDir);
        }
    });
}
exports.clearCache = clearCache;
function gatherJsBundles(bundle, gatheredBundles = []) {
    if (bundle.type === 'js') {
        let map = undefined;
        for (const childBundle of bundle.childBundles) {
            if (childBundle.name.endsWith('.js.map')) {
                map = childBundle.name;
                break;
            }
        }
        gatheredBundles.push({
            src: bundle.name,
            map,
        });
    }
    for (const childBundle of bundle.childBundles) {
        gatherJsBundles(childBundle, gatheredBundles);
    }
    return gatheredBundles;
}
/**
 * Changes the files from the generated bundle to *really*
 * follow the desired preset environment - which includes also
 * packages coming from node_modules.
 * @param mainBundle The main bundle coming from Parcel.
 * @param rootDir The project's root dir.
 */
function postTransform(mainBundle, rootDir) {
    const bundles = gatherJsBundles(mainBundle);
    log_1.logInfo('Post-transforming the emitted bundle(s) ...');
    return Promise.all(bundles.map((bundle) => __awaiter(this, void 0, void 0, function* () {
        const inputSourceMap = bundle.map && (yield io_1.readJson(path_1.dirname(bundle.map), path_1.basename(bundle.map)));
        const { code, map } = yield core_1.transformFileAsync(bundle.src, {
            presets: [['@babel/preset-env']],
            sourceMaps: true,
            minified: true,
            inputSourceMap,
            sourceType: 'script',
            cwd: rootDir,
        });
        yield io_1.writeText(path_1.dirname(bundle.src), path_1.basename(bundle.src), code);
        if (bundle.map) {
            yield io_1.writeJson(path_1.dirname(bundle.map), path_1.basename(bundle.map), map);
        }
    })));
}
exports.postTransform = postTransform;
//# sourceMappingURL=bundler.js.map