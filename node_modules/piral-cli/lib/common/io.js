"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const glob = require("glob");
const rimraf = require("rimraf");
const typescript_1 = require("typescript");
const path_1 = require("path");
const fs_1 = require("fs");
const merge_1 = require("./merge");
const interactive_1 = require("./interactive");
const info_1 = require("./info");
const hash_1 = require("./hash");
var ForceOverwrite;
(function (ForceOverwrite) {
    ForceOverwrite[ForceOverwrite["no"] = 0] = "no";
    ForceOverwrite[ForceOverwrite["prompt"] = 1] = "prompt";
    ForceOverwrite[ForceOverwrite["yes"] = 2] = "yes";
})(ForceOverwrite = exports.ForceOverwrite || (exports.ForceOverwrite = {}));
function promptOverwrite(file) {
    const message = `The file ${file} exists already. Do you want to overwrite it?`;
    return interactive_1.promptConfirm(message, false);
}
function createDirectoryLegacy(targetDir) {
    const initDir = path_1.isAbsolute(targetDir) ? path_1.sep : '';
    return targetDir.split(path_1.sep).reduce((parentDir, childDir) => {
        const curDir = path_1.resolve(parentDir, childDir);
        try {
            fs_1.mkdirSync(curDir);
        }
        catch (err) {
            if (err.code === 'EEXIST') {
                return curDir;
            }
            if (err.code === 'ENOENT') {
                throw new Error(`EACCES: permission denied, mkdir '${parentDir}'`);
            }
            const caughtErr = ['EACCES', 'EPERM', 'EISDIR'].indexOf(err.code) > -1;
            if (!caughtErr || (caughtErr && curDir === path_1.resolve(targetDir))) {
                throw err;
            }
        }
        return curDir;
    }, initDir);
}
function isFile(file) {
    return fs_1.statSync(file).isFile();
}
function isLegacy() {
    const parts = info_1.nodeVersion.split('.');
    return +parts[0] < 10 || (+parts[0] === 10 && +parts[1] < 12);
}
function removeDirectory(targetDir) {
    return new Promise((resolve, reject) => rimraf(targetDir, err => (err ? reject(err) : resolve())));
}
exports.removeDirectory = removeDirectory;
function createDirectory(targetDir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isLegacy()) {
            try {
                createDirectoryLegacy(targetDir);
                return true;
            }
            catch (e) {
                console.error(`Error while creating ${targetDir}: `, e);
                return false;
            }
        }
        try {
            yield new Promise((resolve, reject) => {
                fs_1.mkdir(targetDir, { recursive: true }, err => (err ? reject(err) : resolve()));
            });
            return true;
        }
        catch (e) {
            console.error(`Error while creating ${targetDir}: `, e);
            return false;
        }
    });
}
exports.createDirectory = createDirectory;
function checkExists(target) {
    return new Promise(resolve => {
        fs_1.exists(target, resolve);
    });
}
exports.checkExists = checkExists;
function checkExistingDirectory(target) {
    return __awaiter(this, void 0, void 0, function* () {
        if (yield checkExists(target)) {
            return yield checkIsDirectory(target);
        }
        return false;
    });
}
exports.checkExistingDirectory = checkExistingDirectory;
function checkIsDirectory(target) {
    return new Promise(resolve => {
        fs_1.lstat(target, (err, stats) => {
            if (err) {
                resolve(path_1.extname(target) === '');
            }
            else {
                resolve(stats.isDirectory());
            }
        });
    });
}
exports.checkIsDirectory = checkIsDirectory;
function getFileWithExtension(fileName) {
    if (!path_1.extname(fileName)) {
        const extensions = ['.tsx', '.ts', '.jsx', '.js'];
        for (const extension of extensions) {
            const file = fileName + extension;
            if (fs_1.existsSync(file)) {
                return file;
            }
        }
    }
    return fileName;
}
exports.getFileWithExtension = getFileWithExtension;
function findFile(topDir, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        const path = path_1.join(topDir, fileName);
        const exists = yield checkExists(path);
        if (!exists) {
            const parentDir = path_1.resolve(topDir, '..');
            if (parentDir !== topDir) {
                return yield findFile(parentDir, fileName);
            }
            return undefined;
        }
        return path;
    });
}
exports.findFile = findFile;
function matchFiles(baseDir, pattern) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            glob(pattern, {
                cwd: baseDir,
                absolute: true,
            }, (err, files) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(files.filter(isFile));
                }
            });
        });
    });
}
exports.matchFiles = matchFiles;
function createFileIfNotExists(targetDir, fileName, content, forceOverwrite = ForceOverwrite.no) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = path_1.join(targetDir, fileName);
        const exists = yield checkExists(targetFile);
        if (!exists ||
            forceOverwrite === ForceOverwrite.yes ||
            (forceOverwrite === ForceOverwrite.prompt && (yield promptOverwrite(targetFile)))) {
            yield createDirectory(path_1.dirname(targetFile));
            yield new Promise((resolve, reject) => {
                fs_1.writeFile(targetFile, content, 'utf8', err => (err ? reject(err) : resolve()));
            });
        }
    });
}
exports.createFileIfNotExists = createFileIfNotExists;
function updateExistingFile(targetDir, fileName, content) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = path_1.join(targetDir, fileName);
        const exists = yield checkExists(targetFile);
        if (exists) {
            yield new Promise((resolve, reject) => {
                fs_1.writeFile(targetFile, content, 'utf8', err => (err ? reject(err) : resolve()));
            });
        }
    });
}
exports.updateExistingFile = updateExistingFile;
function getHash(targetFile) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            fs_1.readFile(targetFile, (err, c) => (err ? resolve(undefined) : resolve(hash_1.computeHash(c))));
        });
    });
}
exports.getHash = getHash;
function mergeWithJson(targetDir, fileName, newContent) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = path_1.join(targetDir, fileName);
        const content = yield new Promise((resolve, reject) => {
            fs_1.readFile(targetFile, 'utf8', (err, c) => (err ? reject(err) : resolve(c)));
        });
        const originalContent = JSON.parse(content);
        return merge_1.deepMerge(originalContent, newContent);
    });
}
exports.mergeWithJson = mergeWithJson;
function readJson(targetDir, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = path_1.join(targetDir, fileName);
        const content = yield new Promise(resolve => {
            fs_1.readFile(targetFile, 'utf8', (err, c) => (err ? resolve('') : resolve(c)));
        });
        return JSON.parse(content || '{}');
    });
}
exports.readJson = readJson;
function writeJson(targetDir, fileName, data) {
    return writeText(targetDir, fileName, JSON.stringify(data));
}
exports.writeJson = writeJson;
function readBinary(targetDir, fileName) {
    const targetFile = path_1.join(targetDir, fileName);
    return new Promise(resolve => {
        fs_1.readFile(targetFile, (err, c) => (err ? resolve(undefined) : resolve(c)));
    });
}
exports.readBinary = readBinary;
function writeText(targetDir, fileName, data) {
    const targetFile = path_1.join(targetDir, fileName);
    return new Promise((resolve, reject) => {
        fs_1.writeFile(targetFile, data, 'utf8', err => (err ? reject() : resolve()));
    });
}
exports.writeText = writeText;
function readText(targetDir, fileName) {
    const targetFile = path_1.join(targetDir, fileName);
    return new Promise(resolve => {
        fs_1.readFile(targetFile, 'utf8', (err, c) => (err ? resolve(undefined) : resolve(c)));
    });
}
exports.readText = readText;
function updateExistingJson(targetDir, fileName, newContent) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = yield mergeWithJson(targetDir, fileName, newContent);
        yield updateExistingFile(targetDir, fileName, JSON.stringify(content, undefined, 2));
    });
}
exports.updateExistingJson = updateExistingJson;
function copy(source, target, forceOverwrite = ForceOverwrite.no) {
    return __awaiter(this, void 0, void 0, function* () {
        yield createDirectory(path_1.dirname(target));
        try {
            const flag = forceOverwrite === ForceOverwrite.yes ? 0 : fs_1.constants.COPYFILE_EXCL;
            yield new Promise((resolve, reject) => {
                fs_1.copyFile(source, target, flag, err => (err ? reject(err) : resolve()));
            });
        }
        catch (e) {
            if (forceOverwrite === ForceOverwrite.prompt) {
                const shouldOverwrite = yield promptOverwrite(target);
                if (shouldOverwrite) {
                    yield copy(source, target, ForceOverwrite.yes);
                }
            }
            else {
                console.warn(e.message || `Did not overwrite: File ${target} already exists.`);
            }
        }
    });
}
exports.copy = copy;
function remove(target) {
    return new Promise((resolve, reject) => {
        fs_1.unlink(target, err => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.remove = remove;
function move(source, target, forceOverwrite = ForceOverwrite.no) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = yield checkIsDirectory(target);
        if (dir) {
            const file = path_1.basename(source);
            target = path_1.resolve(target, file);
        }
        yield copy(source, target, forceOverwrite);
        yield remove(source);
        return target;
    });
}
exports.move = move;
function getSourceFiles(entry) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = path_1.dirname(entry);
        const files = yield matchFiles(dir, '**/*.?(jsx|tsx|js|ts)');
        return files.map(path => {
            const directory = path_1.dirname(path);
            const name = path_1.basename(path);
            return {
                path,
                directory,
                name,
                read() {
                    return __awaiter(this, void 0, void 0, function* () {
                        const content = yield readText(directory, name);
                        if (name.endsWith('.ts') || name.endsWith('.tsx')) {
                            return typescript_1.transpileModule(content, {
                                fileName: path,
                                moduleName: name,
                                compilerOptions: {
                                    allowJs: true,
                                    skipLibCheck: true,
                                    declaration: false,
                                    sourceMap: false,
                                    checkJs: false,
                                    jsx: typescript_1.JsxEmit.React,
                                    module: typescript_1.ModuleKind.ESNext,
                                    moduleResolution: typescript_1.ModuleResolutionKind.NodeJs,
                                    target: typescript_1.ScriptTarget.ESNext,
                                },
                            }).outputText;
                        }
                        return content;
                    });
                },
            };
        });
    });
}
exports.getSourceFiles = getSourceFiles;
//# sourceMappingURL=io.js.map