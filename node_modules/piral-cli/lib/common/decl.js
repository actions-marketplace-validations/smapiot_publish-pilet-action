"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const io_1 = require("./io");
const package_1 = require("./package");
const importDeclRx = /import\s+((.*?)\s+from\s*)?['"`](.*?)['"`]\s*;?/g;
const exportDeclRx = /export\s+((.*?)\s+from\s*){1}['"`](.*?)['"`]\s*;?/g;
const allowedPackages = ['piral', 'react-arbiter', 'react-atom', '@dbeining/react-atom'];
function combineApiDeclarations(root, dependencyNames) {
    const names = [root, ...dependencyNames];
    const paths = [];
    for (const name of names) {
        try {
            const moduleName = `${name}/api`;
            const target = `${moduleName}.d.ts`;
            require.resolve(target);
            paths.push(moduleName);
        }
        catch (_a) {
            //Skip module that cannot be resolved
        }
    }
    const imports = paths.map(path => `import '${path}';`).join('\n');
    return `${imports}

export * from 'piral-core/api';`;
}
exports.combineApiDeclarations = combineApiDeclarations;
function isContainedPackage(name) {
    return name.startsWith('piral-') || allowedPackages.includes(name);
}
function declarationPath(path) {
    const extPath = path + '.d.ts';
    const indexPath = path_1.resolve(path, 'index.d.ts');
    if (fs_1.existsSync(path) && fs_1.statSync(path).isFile()) {
        return path;
    }
    else if (fs_1.existsSync(extPath)) {
        return extPath;
    }
    else if (fs_1.existsSync(indexPath)) {
        return indexPath;
    }
    return undefined;
}
function splitPackageName(moduleName) {
    if (moduleName.startsWith('@')) {
        const [scope, name, ...rest] = moduleName.split('/');
        return [`${scope}/${name}`, rest.join('/')];
    }
    else {
        const [name, ...rest] = moduleName.split('/');
        return [name, rest.join('/')];
    }
}
function packagePath(baseDir, moduleName) {
    const [name, relPath] = splitPackageName(moduleName);
    if (isContainedPackage(name)) {
        const targetJsonPath = package_1.findPackageRoot(name, baseDir);
        const targetJsonData = require(targetJsonPath);
        const root = path_1.dirname(targetJsonPath);
        const relTypings = relPath || targetJsonData.typings || targetJsonData.main.replace('.js', '.d.ts');
        return declarationPath(path_1.resolve(root, relTypings));
    }
    return undefined;
}
function normalizePath(baseDir, name) {
    if (path_1.isAbsolute(name)) {
        return declarationPath(name);
    }
    else if (name.startsWith('.')) {
        return declarationPath(path_1.resolve(baseDir, name));
    }
    else {
        return packagePath(baseDir, name);
    }
}
function modularize(path) {
    if (path.endsWith('.d.ts')) {
        path = path.substr(0, path.length - 5);
    }
    if (path.endsWith(`${path_1.sep}index`)) {
        path = path.substr(0, path.length - 6);
    }
    const fullPath = path;
    while (!fs_1.existsSync(path_1.join(path, 'package.json'))) {
        path = path_1.join(path, '..');
    }
    return path_1.relative(path_1.join(path, '..'), fullPath);
}
function getReferences(rx, baseDir, content) {
    const references = [];
    let match = true;
    while (match) {
        match = rx.exec(content);
        if (match) {
            const relName = match[3];
            const path = normalizePath(baseDir, relName);
            if (path !== undefined) {
                const name = modularize(path);
                const original = match[0];
                const modified = name === relName ? original : original.replace(relName, name);
                references.push({
                    name,
                    path,
                    fields: match[2],
                    original,
                    modified,
                });
            }
        }
    }
    return references;
}
function format(content, references) {
    for (const reference of references) {
        content = content.replace(reference.original, reference.modified);
    }
    return content
        .replace(/declare (module|type|const|function|class)/g, '$1')
        .split('\n')
        .join('\n  ');
}
function readNextFile(ref, files) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!files.some(file => file.path === ref.path)) {
            const referenceBaseDir = path_1.dirname(ref.path);
            const referenceFileName = path_1.basename(ref.path);
            const content = yield io_1.readText(referenceBaseDir, referenceFileName);
            return {
                baseDir: referenceBaseDir,
                fileName: referenceFileName,
                moduleName: ref.name,
                content,
            };
        }
    });
}
function unique(ref, index, self) {
    return self.findIndex(m => m.path === ref.path) === index;
}
function traverseFiles(files, { baseDir, content, fileName, moduleName }) {
    return __awaiter(this, void 0, void 0, function* () {
        const exportRefs = getReferences(exportDeclRx, baseDir, content);
        const importRefs = getReferences(importDeclRx, baseDir, content);
        const references = [...importRefs, ...exportRefs];
        files.push({
            content: `declare module '${moduleName}' {
  ${format(content, references)}
}`,
            path: path_1.resolve(baseDir, fileName),
            exports: exportRefs,
            imports: importRefs,
        });
        const nextRefs = references.filter(unique).map(ref => readNextFile(ref, files));
        const resolvedRefs = yield Promise.all(nextRefs);
        const childFiles = resolvedRefs.filter(ref => !!ref);
        yield Promise.all(childFiles.map(ref => traverseFiles(files, ref)));
    });
}
function declarationFlattening(baseDir, appName, content) {
    return __awaiter(this, void 0, void 0, function* () {
        const allFiles = [];
        yield traverseFiles(allFiles, {
            baseDir,
            fileName: 'index.d.ts',
            moduleName: appName,
            content,
        });
        return allFiles
            .filter(unique)
            .map(file => file.content)
            .join('\n\n');
    });
}
exports.declarationFlattening = declarationFlattening;
//# sourceMappingURL=decl.js.map