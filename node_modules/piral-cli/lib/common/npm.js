"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const MemoryStream_1 = require("./MemoryStream");
const info_1 = require("./info");
const inspect_1 = require("./inspect");
const io_1 = require("./io");
const scripts_1 = require("./scripts");
const log_1 = require("./log");
const npmCommand = info_1.isWindows ? 'npm.cmd' : 'npm';
function runNpmProcess(args, target, output) {
    const cwd = path_1.resolve(process.cwd(), target);
    const cmd = [npmCommand, ...args].join(' ');
    return scripts_1.runScript(cmd, cwd, output);
}
function isLocalPackage(baseDir, fullName) {
    if (/^[\.\/\~]/.test(fullName)) {
        return true;
    }
    else if (fullName.endsWith('.tgz')) {
        return fs_1.existsSync(path_1.resolve(baseDir, fullName));
    }
    return false;
}
exports.isLocalPackage = isLocalPackage;
function isGitPackage(fullName) {
    const gitted = fullName.startsWith(gitPrefix);
    return gitted || /^(https?|ssh):\/\/.*\.git$/.test(fullName);
}
exports.isGitPackage = isGitPackage;
function installDependencies(target = '.', ...flags) {
    return runNpmProcess(['install', ...flags], target);
}
exports.installDependencies = installDependencies;
function installPackage(packageRef, target = '.', ...flags) {
    return runNpmProcess(['install', packageRef, ...flags], target);
}
exports.installPackage = installPackage;
function createPackage(target = '.', ...flags) {
    return runNpmProcess(['pack', ...flags], target);
}
exports.createPackage = createPackage;
function findLatestVersion(packageName) {
    return __awaiter(this, void 0, void 0, function* () {
        const ms = new MemoryStream_1.MemoryStream();
        yield runNpmProcess(['show', packageName, 'version'], '.', ms);
        return ms.value;
    });
}
exports.findLatestVersion = findLatestVersion;
function makeGitUrl(fullName) {
    const gitted = fullName.startsWith(gitPrefix);
    return gitted ? fullName : `${gitPrefix}${fullName}`;
}
exports.makeGitUrl = makeGitUrl;
const gitPrefix = 'git+';
const filePrefix = 'file:';
/**
 * Looks at the provided package name and normalizes it
 * resulting in the following tuple:
 * [
 *   normalized / real package name,
 *   found package version / version identifier,
 *   indicator if an explicit version was used,
 *   the used package type
 * ]
 * @param baseDir The base directory of the current operation.
 * @param fullName The provided package name.
 */
function dissectPackageName(baseDir, fullName) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isGitPackage(fullName)) {
            const gitUrl = makeGitUrl(fullName);
            return [gitUrl, 'latest', false, 'git'];
        }
        else if (isLocalPackage(baseDir, fullName)) {
            const fullPath = path_1.resolve(baseDir, fullName);
            const exists = yield io_1.checkExists(fullPath);
            if (!exists) {
                throw new Error(`Could not find "${fullPath}" for scaffolding. Aborting.`);
            }
            return [fullPath, 'latest', false, 'file'];
        }
        else {
            const index = fullName.indexOf('@', 1);
            const type = 'registry';
            if (index !== -1) {
                return [fullName.substr(0, index), fullName.substr(index + 1), true, type];
            }
            return [fullName, 'latest', false, type];
        }
    });
}
exports.dissectPackageName = dissectPackageName;
/**
 * Looks at the current package name / version and
 * normalizes it resulting in the following tuple:
 * [
 *   normalized / real package name,
 *   found package version / version identifier,
 * ]
 * @param baseDir The base directory of the current operation.
 * @param sourceName The used package name.
 * @param sourceVersion The used package version.
 * @param desired The desired package version.
 */
function getCurrentPackageDetails(baseDir, sourceName, sourceVersion, desired) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isLocalPackage(baseDir, desired)) {
            const fullPath = path_1.resolve(baseDir, desired);
            const exists = yield io_1.checkExists(fullPath);
            if (!exists) {
                throw new Error(`Could not find "${fullPath}" for upgrading. Aborting.`);
            }
            return [fullPath, getFilePackageVersion(fullPath)];
        }
        else if (isGitPackage(desired)) {
            const gitUrl = makeGitUrl(desired);
            return [gitUrl, getGitPackageVersion(gitUrl)];
        }
        else if (sourceVersion && sourceVersion.startsWith('file:')) {
            log_1.logWarn('The Piral instance is currently resolved locally, but no local file for the upgrade has been specified.');
            log_1.logInfo('Trying to obtain the pilet from NPM instead.');
        }
        else if (sourceVersion && sourceVersion.startsWith('git+')) {
            if (desired === 'latest') {
                const gitUrl = desired;
                return [gitUrl, getGitPackageVersion(gitUrl)];
            }
            else {
                log_1.logWarn('The Piral instance is currently resolved via Git, but latest was not used to try a direct update.');
                log_1.logInfo('Trying to obtain the pilet from NPM instead.');
            }
        }
        return [combinePackageRef(sourceName, desired, 'registry'), desired];
    });
}
exports.getCurrentPackageDetails = getCurrentPackageDetails;
function combinePackageRef(name, version, type) {
    if (type === 'registry') {
        return `${name}@${version}`;
    }
    return name;
}
exports.combinePackageRef = combinePackageRef;
function getPackageName(root, name, type) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (type) {
            case 'file':
                const p = path_1.resolve(process.cwd(), name);
                const s = fs_1.createReadStream(p);
                const i = yield inspect_1.inspectPackage(s);
                return i.name;
            case 'git':
                const pj = yield io_1.readJson(root, 'package.json');
                const dd = pj.devDependencies || {};
                return Object.keys(dd).filter(dep => dd[dep] === name)[0];
            case 'registry':
                return name;
        }
    });
}
exports.getPackageName = getPackageName;
function getFilePackageVersion(sourceName) {
    return `${filePrefix}${sourceName}`;
}
exports.getFilePackageVersion = getFilePackageVersion;
function getGitPackageVersion(sourceName) {
    return `${sourceName}`;
}
exports.getGitPackageVersion = getGitPackageVersion;
function getPackageVersion(hadVersion, sourceName, sourceVersion, type) {
    switch (type) {
        case 'registry':
            return hadVersion && sourceVersion;
        case 'file':
            return getFilePackageVersion(sourceName);
        case 'git':
            return getGitPackageVersion(sourceName);
    }
}
exports.getPackageVersion = getPackageVersion;
//# sourceMappingURL=npm.js.map