"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const language_1 = require("./language");
const template_1 = require("./template");
const io_1 = require("./io");
function scaffoldPiralSourceFiles(type, language, root, app, packageName, forceOverwrite) {
    return __awaiter(this, void 0, void 0, function* () {
        const src = path_1.dirname(path_1.join(root, app));
        const mocks = path_1.join(src, 'mocks');
        const appTemplate = yield template_1.fillTemplate(type, 'piral-index.html', {
            extension: language_1.getLanguageExtension(language),
        });
        yield io_1.createFileIfNotExists(root, app, appTemplate, forceOverwrite);
        yield template_1.createFileFromTemplateIfNotExists(type, 'piral', mocks, 'backend.js', forceOverwrite);
        yield template_1.createFileFromTemplateIfNotExists(type, 'piral', src, 'style.scss', forceOverwrite);
        switch (language) {
            case language_1.PiletLanguage.ts:
                yield template_1.createFileFromTemplateIfNotExists(type, 'piral', root, 'tsconfig.json', forceOverwrite, {
                    src: path_1.relative(root, src),
                });
                yield template_1.createFileFromTemplateIfNotExists(type, 'piral', src, 'layout.tsx', forceOverwrite);
                yield template_1.createFileFromTemplateIfNotExists(type, 'piral', src, 'index.tsx', forceOverwrite, {
                    packageName,
                });
                break;
            case language_1.PiletLanguage.js:
                yield template_1.createFileFromTemplateIfNotExists(type, 'piral', src, 'layout.jsx', forceOverwrite);
                yield template_1.createFileFromTemplateIfNotExists(type, 'piral', src, 'index.jsx', forceOverwrite, {
                    packageName,
                });
                break;
        }
    });
}
exports.scaffoldPiralSourceFiles = scaffoldPiralSourceFiles;
function scaffoldPiletSourceFiles(type, language, root, sourceName, forceOverwrite) {
    return __awaiter(this, void 0, void 0, function* () {
        const src = path_1.join(root, 'src');
        yield io_1.createDirectory(src);
        switch (language) {
            case language_1.PiletLanguage.ts:
                yield template_1.createFileFromTemplateIfNotExists(type, 'pilet', root, 'tsconfig.json', forceOverwrite, {
                    src: path_1.relative(root, src),
                });
                yield template_1.createFileFromTemplateIfNotExists(type, 'pilet', src, 'index.tsx', forceOverwrite, {
                    sourceName,
                });
                break;
            case language_1.PiletLanguage.js:
                yield template_1.createFileFromTemplateIfNotExists(type, 'pilet', src, 'index.jsx', forceOverwrite, {
                    sourceName,
                });
                break;
        }
    });
}
exports.scaffoldPiletSourceFiles = scaffoldPiletSourceFiles;
//# sourceMappingURL=scaffold.js.map