"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Bundler = require("parcel-bundler");
const path_1 = require("path");
const common_1 = require("../common");
function getDestination(entryFiles, target) {
    const isdir = path_1.extname(target) !== '.html';
    if (isdir) {
        return {
            outDir: target,
            outFile: path_1.basename(entryFiles),
        };
    }
    else {
        return {
            outDir: path_1.dirname(target),
            outFile: path_1.basename(target),
        };
    }
}
function bundleFiles(piral, develop, target, dependencies, entryFiles, dest, subdir, config, transformRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        const outDir = path_1.join(dest.outDir, subdir);
        yield common_1.setStandardEnvs({
            production: true,
            target,
            develop,
            piral,
            dependencies,
        });
        common_1.modifyBundlerForPiral(Bundler.prototype, target);
        const bundler = new Bundler(entryFiles, common_1.extendConfig(Object.assign(Object.assign({}, config), { outDir, outFile: dest.outFile })));
        common_1.extendBundlerForPiral(bundler);
        common_1.extendBundlerWithPlugins(bundler);
        const bundle = yield bundler.bundle();
        if (transformRoot && config.minify) {
            yield common_1.postTransform(bundle, transformRoot);
        }
        return outDir;
    });
}
function generateDeclaration(outDir, root, name, dependencies) {
    return __awaiter(this, void 0, void 0, function* () {
        const declaration = common_1.combineApiDeclarations(root, Object.keys(dependencies));
        const result = yield common_1.declarationFlattening(root, name, declaration);
        yield common_1.createFileIfNotExists(outDir, 'index.d.ts', result);
    });
}
exports.buildPiralDefaults = {
    entry: './',
    target: './dist',
    publicUrl: '/',
    cacheDir: '.cache',
    detailedReport: false,
    logLevel: 3,
    fresh: false,
    minify: true,
    type: 'all',
    sourceMaps: true,
    contentHash: true,
    scopeHoist: false,
};
function buildPiral(baseDir = process.cwd(), options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { entry = exports.buildPiralDefaults.entry, target = exports.buildPiralDefaults.target, publicUrl = exports.buildPiralDefaults.publicUrl, detailedReport = exports.buildPiralDefaults.detailedReport, logLevel = exports.buildPiralDefaults.logLevel, cacheDir = exports.buildPiralDefaults.cacheDir, minify = exports.buildPiralDefaults.minify, sourceMaps = exports.buildPiralDefaults.sourceMaps, contentHash = exports.buildPiralDefaults.contentHash, scopeHoist = exports.buildPiralDefaults.scopeHoist, fresh = exports.buildPiralDefaults.fresh, type = exports.buildPiralDefaults.type, } = options;
        const entryFiles = yield common_1.retrievePiralRoot(baseDir, entry);
        const targetDir = path_1.dirname(entryFiles);
        const _a = yield common_1.retrievePiletsInfo(entryFiles), { name, version, root, dependencies } = _a, pilets = __rest(_a, ["name", "version", "root", "dependencies"]);
        const { externals } = pilets;
        const dest = getDestination(entryFiles, path_1.resolve(baseDir, target));
        if (fresh) {
            yield common_1.clearCache(root, cacheDir);
        }
        yield common_1.removeDirectory(dest.outDir);
        // everything except release -> build develop
        if (type !== 'release') {
            common_1.logInfo('Starting build ...');
            // we'll need this info for later
            const originalPackageJson = path_1.resolve(root, 'package.json');
            const { files: originalFiles = [] } = require(originalPackageJson);
            const appDir = 'app';
            const outDir = yield bundleFiles(name, true, targetDir, externals, entryFiles, dest, path_1.join('develop', appDir), {
                cacheDir,
                watch: false,
                sourceMaps,
                contentHash,
                minify,
                scopeHoist,
                detailedReport,
                publicUrl,
                logLevel,
            });
            const allExternals = [...externals, ...common_1.coreExternals];
            const externalPackages = yield Promise.all(allExternals.map((name) => __awaiter(this, void 0, void 0, function* () {
                return ({
                    name,
                    version: yield common_1.findPackageVersion(targetDir, name),
                });
            })));
            const externalDependencies = externalPackages.reduce((deps, dep) => {
                deps[dep.name] = dep.version;
                return deps;
            }, {});
            const rootDir = path_1.resolve(outDir, '..');
            const filesDir = path_1.resolve(rootDir, 'files');
            const files = pilets.files
                .map(file => (typeof file === 'string' ? { from: file, to: file } : file))
                .map(file => (Object.assign(Object.assign({}, file), { from: path_1.join('files', file.from) })));
            yield common_1.createFileIfNotExists(rootDir, 'package.json', '{}');
            yield common_1.updateExistingJson(rootDir, 'package.json', {
                name,
                version,
                pilets: Object.assign(Object.assign({}, pilets), { files }),
                piralCLI: {
                    version: common_1.cliVersion,
                    generated: true,
                },
                main: `${appDir}/index.js`,
                typings: `${appDir}/index.d.ts`,
                app: `${appDir}/index.html`,
                peerDependencies: {},
                devDependencies: Object.assign(Object.assign(Object.assign({}, dependencies.dev), dependencies.std), externalDependencies),
            });
            yield common_1.createDirectory(filesDir);
            // for scaffolding we need to keep the files also available in the new package
            yield common_1.copyScaffoldingFiles(root, filesDir, pilets.files);
            // we just want to make sure that "files" mentioned in the original package.json are respected in the package
            yield common_1.copyScaffoldingFiles(root, rootDir, originalFiles);
            // actually including this one hints that the app shell should have been included - which is forbidden
            yield common_1.createFileIfNotExists(outDir, 'index.js', 'throw new Error("This file should not be included anywhere.");');
            yield generateDeclaration(outDir, root, name, dependencies.std);
            yield common_1.createPackage(rootDir);
            yield Promise.all([common_1.removeDirectory(outDir), common_1.removeDirectory(filesDir), common_1.remove(path_1.resolve(rootDir, 'package.json'))]);
            common_1.logDone(`Development package available in "${rootDir}".`);
        }
        if (type === 'all') {
            // Just have some space between the two builds
            common_1.logInfo('\n\n\n\n\n\n');
        }
        // everything except develop -> build release
        if (type !== 'develop') {
            common_1.logInfo('Starting build ...');
            const outDir = yield bundleFiles(name, false, targetDir, externals, entryFiles, dest, 'release', {
                cacheDir,
                watch: false,
                sourceMaps,
                contentHash,
                minify,
                scopeHoist,
                detailedReport,
                publicUrl,
                logLevel,
            }, root);
            common_1.logDone(`Files for publication available in "${outDir}".`);
        }
    });
}
exports.buildPiral = buildPiral;
//# sourceMappingURL=build-piral.js.map