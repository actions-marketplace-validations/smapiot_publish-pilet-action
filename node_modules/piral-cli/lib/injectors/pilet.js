"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const mime_1 = require("mime");
const fs_1 = require("fs");
class PiletInjector {
    constructor(options, _, core) {
        this.config = options;
        const { bundler, api } = options;
        const cbs = {};
        core.on('user-connected', e => {
            if (e.target === '*' && e.url === api.substr(1)) {
                cbs[e.id] = (msg) => e.ws.send(msg);
            }
        });
        core.on('user-disconnected', e => {
            delete cbs[e.id];
        });
        bundler.on('bundle-ready', () => {
            const meta = this.getMeta();
            for (const id of Object.keys(cbs)) {
                cbs[id](meta);
            }
        });
    }
    get active() {
        return this.config.active;
    }
    set active(value) {
        this.config.active = value;
    }
    get name() {
        return 'pilet-injector';
    }
    getOptions() {
        return {};
    }
    setOptions() { }
    getMeta() {
        const { bundler, root, port, api } = this.config;
        const dir = bundler.options.outDir;
        const def = JSON.parse(fs_1.readFileSync(path_1.join(root, 'package.json'), 'utf8'));
        const link = bundler.mainBundle.name.substr(dir.length + 1);
        return JSON.stringify({
            name: def.name,
            version: def.version,
            link: `http://localhost:${port}${api}/${link}`,
            hash: bundler.mainBundle.entryAsset.hash,
            noCache: true,
            custom: def.custom,
        });
    }
    sendContent(content, type, url) {
        return {
            injector: { name: this.name },
            headers: {
                'content-type': type,
                'cache-control': 'no-cache, no-store, must-revalidate',
                pragma: 'no-cache',
                expires: '0',
            },
            status: { code: 200 },
            url,
            content,
        };
    }
    sendFile(target, url) {
        const content = fs_1.readFileSync(target);
        return this.sendContent(content, mime_1.getType(target), url);
    }
    sendResponse(path, target, url) {
        if (!path) {
            const content = this.getMeta();
            return this.sendContent(content, 'application/json', url);
        }
        else if (fs_1.existsSync(target) && fs_1.statSync(target).isFile()) {
            return this.sendFile(target, url);
        }
    }
    handle(req) {
        const { bundler, app, api } = this.config;
        if (req.target !== api) {
            const path = req.url.substr(1);
            const target = path_1.join(app, path);
            if (fs_1.existsSync(target) && fs_1.statSync(target).isFile()) {
                return this.sendFile(target, req.url);
            }
            else {
                return this.handle(Object.assign(Object.assign({}, req), { url: '/index.html' }));
            }
        }
        else {
            const path = req.url.substr(1).split('?')[0];
            const target = path_1.join(bundler.options.outDir, path);
            if (bundler.pending) {
                return new Promise(resolve => {
                    bundler.once('bundled', () => resolve(this.sendResponse(path, target, req.url)));
                });
            }
            return this.sendResponse(path, target, req.url);
        }
    }
}
exports.default = PiletInjector;
//# sourceMappingURL=pilet.js.map