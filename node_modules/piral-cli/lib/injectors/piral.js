"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const mime_1 = require("mime");
const fs_1 = require("fs");
class PiralInjector {
    constructor(options) {
        this.config = options;
    }
    get active() {
        return this.config.active;
    }
    set active(value) {
        this.config.active = value;
    }
    get name() {
        return 'piral-injector';
    }
    getOptions() {
        return {};
    }
    setOptions() { }
    sendResponse(path, target, dir, url) {
        if (!path || !fs_1.existsSync(target) || !fs_1.statSync(target).isFile()) {
            const { bundler } = this.config;
            const newTarget = bundler.mainBundle.name;
            return this.sendResponse(newTarget.substr(dir.length), newTarget, dir, url);
        }
        return {
            injector: { name: this.name },
            headers: {
                'content-type': mime_1.getType(target),
                'cache-control': 'no-cache, no-store, must-revalidate',
                pragma: 'no-cache',
                expires: '0',
            },
            status: { code: 200 },
            url,
            content: fs_1.readFileSync(target),
        };
    }
    handle(req) {
        const { bundler } = this.config;
        const path = req.url.substr(1);
        const dir = bundler.options.outDir;
        const target = path_1.join(dir, path.split('?')[0]);
        if (bundler.pending) {
            return new Promise(resolve => {
                bundler.once('bundled', () => resolve(this.sendResponse(path, target, dir, req.url)));
            });
        }
        return this.sendResponse(path, target, dir, req.url);
    }
}
exports.default = PiralInjector;
//# sourceMappingURL=piral.js.map