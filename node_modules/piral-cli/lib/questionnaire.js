"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const inquirer_1 = require("inquirer");
const commands_1 = require("./commands");
function getCommandData(retrieve) {
    const instructions = [];
    const fn = {
        positional(name, info) {
            instructions.push(Object.assign(Object.assign({}, info), { name }));
            return this;
        },
        swap(name, swapper) {
            const [flag] = instructions.filter(m => m.name === name);
            const newFlag = swapper(flag || { name });
            if (!flag) {
                instructions.push(newFlag);
            }
            else {
                Object.assign(flag, newFlag);
            }
            return this;
        },
        choices(name, choices) {
            return this.swap(name, flag => (Object.assign(Object.assign({}, flag), { type: 'string', values: choices })));
        },
        string(name) {
            return this.swap(name, flag => (Object.assign(Object.assign({}, flag), { type: 'string' })));
        },
        boolean(name) {
            return this.swap(name, flag => (Object.assign(Object.assign({}, flag), { type: 'boolean' })));
        },
        describe(name, value) {
            return this.swap(name, flag => (Object.assign(Object.assign({}, flag), { describe: value })));
        },
        default(name, value) {
            return this.swap(name, flag => (Object.assign(Object.assign({}, flag), { default: value })));
        },
        number(name) {
            return this.swap(name, flag => (Object.assign(Object.assign({}, flag), { type: 'number' })));
        },
        demandOption(name) {
            return this.swap(name, flag => (Object.assign(Object.assign({}, flag), { required: true })));
        },
    };
    if (typeof retrieve === 'function') {
        retrieve(fn);
    }
    return instructions;
}
function getValue(type, value) {
    switch (type) {
        case 'boolean':
            return !!value;
        case 'number':
            return +value;
        case 'string':
            return value;
    }
}
function getType(flag) {
    switch (flag.type) {
        case 'string':
            if (flag.values) {
                return 'list';
            }
            return 'input';
        case 'number':
            return 'input';
        case 'boolean':
            return 'confirm';
    }
}
function runQuestionnaire(commandName, ignoredInstructions = ['base']) {
    const [command] = commands_1.commands.all.filter(m => m.name === commandName);
    const instructions = getCommandData(command.flags);
    const questions = instructions
        .filter(instruction => !ignoredInstructions.includes(instruction.name))
        .map(instruction => ({
        name: instruction.name,
        default: instruction.values ? instruction.values.indexOf(instruction.default) : instruction.default,
        message: instruction.describe,
        type: getType(instruction),
        choices: instruction.values,
        validate: instruction.type === 'number' ? (input) => !isNaN(+input) : () => true,
    }));
    return inquirer_1.prompt(questions).then(answers => {
        const parameters = {};
        for (const instruction of instructions) {
            const value = answers[instruction.name];
            parameters[instruction.name] =
                value !== undefined ? getValue(instruction.type, value) : instruction.default;
        }
        return command.run(parameters);
    });
}
exports.runQuestionnaire = runQuestionnaire;
//# sourceMappingURL=questionnaire.js.map